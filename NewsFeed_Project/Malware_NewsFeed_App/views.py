from django.shortcuts import render
import requests
import json
import urllib3


####from database_handler_module import *    # jeg har lavet et seperat modul database_handler_module.py



import psycopg2  # postgresql


class ClassThreatDatabase:
    def __init__(this):
        try:
            this.db_connect = psycopg2.connect(host='localhost', user='postgres', password='hemmeligt', port=5432,
                                               dbname="threat_db")
            this.cur = this.db_connect.cursor()
        except:
            print("*" * 50, "No DB connection !", "*" * 50)
        return None

    def funcCreateTable(obj):
        create_table_if_not = """create table if not exists threat_table 
                    (date varchar(40), name varchar(128), 
                    description varchar(4096), malware varchar(1024), ref varchar(2048));"""

        create_table = """create table threat_table 
                            (date varchar(40), name varchar(128), 
                            description varchar(4096), malware varchar(1024), ref varchar(2048));"""
        try:
            obj.cur.execute("drop table if exists threat_table")
            obj.db_connect.commit()
            obj.cur.execute(create_table)
            obj.db_connect.commit()
        except:
            print("Creating table failed")

    def funcDatabaseWrite(obj, list_of_inner_tuples_arg=None):
        insert_into_threat_table = """insert into threat_table 
        (date, name, description, malware, ref) values (%s, %s, %s, %s, %s)"""

        insert_where_not_exists = """
        insert into threat_table (date, name, description, malware, ref) 
        select %s, %s, %s, %s, %s where not exists (select date from threat_table where date=%s);"""
        try:

            for tuple_x in list_of_inner_tuples_arg:
                print(tuple_x[0])
                obj.cur.execute(insert_into_threat_table, tuple_x)
                obj.db_connect.commit()
        except:
            print("*" * 50, "Insert into threat_table failed !", "*" * 50)

    def funcDatabaseClose(obj):
        try:
            obj.cur.close()
            obj.db_connect.close()
        except Exception as error:
            print(error)


#######################################################################################





#######################################################################################


urllib3.disable_warnings()
""" disable_warnings() eksekveres her Og ignorer advarsler om certifikat fejl som untrusted f.eks. ved API udtraek

"""

def funcAPIrequestHeader(API_Key="er slettet af sikkerhed"):
    # her ses default argument value som er sat til min API Key
    # hvis funktionen kaldes uden argument parameter vil argument indeholde min API key
    headers_dict = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "X-OTX-API-KEY": API_Key
          }
    return headers_dict

minHeader = funcAPIrequestHeader()
network_url = "https://otx.alienvault.com/api/v1/pulses/subscribed?page=1"


################################ ################################ ################################

class ClassBuildThreatList():
    def __init__(this_instance, response_data):
        """ this.rsp_data = response_data nedenfor opretter en instance variabel ,
        som giver adgang til argumentet 'response_data' for instancen ,
        se under funktionen 'funcBuildThreatList' og ved obj.threatfeed_dict i naeste funktion
        """
        this_instance.rsp_data = response_data
        return None

    def funcBuildThreatList(obj):
        # konverterer fra json string format til python dictionary format
        # print(obj.rsp_data) JSON data
        obj.threatfeed_dict = json.loads(obj.rsp_data)  # type(threatfeed_dict)     <class 'dict'>
        obj.threat_list = obj.threatfeed_dict['results']  # type(threatfeed_dict['results'])     <class 'list'>
        #
        """
        # print(obj.threatfeed_dict['results'][3]['name'], ' # ', obj.threatfeed_dict['results'][3]['description'])
        # Dictionary key 'results' har value af typen 'list' og hvert element i list er af typen dictionary
        """
        #
        def funcGetKeyValues(key_arg, dict_arg):
            if not key_arg in dict_arg.keys():
                no_value_tuple = "no", key_arg, "provided from data source"
                ########################
                # NEDENFOR: hvert element i tuple bliver joinet til hinanden som tilsammen danner en samlet streng
                no_value_str = " ".join(elm for elm in no_value_tuple)
                return no_value_str
            if not dict_arg[key_arg]:  # True hvis keyvalue IKKE indeholder noget
                no_value_tuple = "no", key_arg, "provided from data source"
                print(no_value_tuple)  #OUTPUT: ('no', 'malware_families', 'provided from data source')
                ########################
                # NEDENFOR: hvert element i tuple bliver joinet til hinanden som tilsammen danner en samlet streng
                no_value_str = " ".join(elm for elm in no_value_tuple)
                print(no_value_str)
                return no_value_str
            if not key_arg == "created":
                return dict_arg[key_arg]  # returnerer alle andre value af key_arg UNDTAGEN created value
            return str(dict_arg[key_arg])[:10] #returnerer created value tidsstreng index 0 -10

        #########################
        outer_list = []
        for dictionary_x in obj.threat_list:
            inner_list = []
            # her er det naeste dictionary for hver iteration gennem list 'threat_list'
            # print(dictionary_x)
            lowercase_dictionary_x = {keys.lower(): values for keys, values in dictionary_x.items()}
            inner_list.append(funcGetKeyValues(key_arg="created", dict_arg=lowercase_dictionary_x))
            inner_list.append(funcGetKeyValues(key_arg="name", dict_arg=lowercase_dictionary_x))
            inner_list.append(funcGetKeyValues(key_arg="description", dict_arg=lowercase_dictionary_x))
            inner_list.append(funcGetKeyValues(key_arg="malware_families", dict_arg=lowercase_dictionary_x))
            inner_list.append(funcGetKeyValues(key_arg="references", dict_arg=lowercase_dictionary_x))
            # print(inner_list)
            outer_list.append(inner_list)
        return outer_list

################################ ################################ ################################
class ClassReadFile(ClassBuildThreatList):
    def __init__(obj_adgang):
        #
        with open("saved_threatfeed_from_get_response.json", "r") as fileThreatfeed:
            obj_adgang.readFileThreatfeed = fileThreatfeed.read()  #er json string format
        #
        return None



################################ ################################ ################################



#############################################################################
def funcGETsavedThreatfeed():
    try:
        obj_ClassReadFile = ClassReadFile()
        file_response_data = obj_ClassReadFile.readFileThreatfeed
        obj_ClassBuildThreatList = ClassBuildThreatList(file_response_data)
        getSavedThreatlist = obj_ClassBuildThreatList.funcBuildThreatList()
        # print(getSavedThreatlist)
        return getSavedThreatlist
    except:
        print("\nNo saved Threat list !\n")
        return False

#############################################################################

def funcAPIThreatfeed():
    print('#' * 50)
    print(' funktionen "funcAPIThreatfeed()" blev eksekveret')
    '''da jeg ikke vil have at der eksekveres en API GET request hver gang en bruger taster URL ind, vil jeg
       assigne funcAPIThreatfeed() til en variabel for at gemme return vaerdien hvor ved at funktionen 
       dvs API kaldet kun sker naar views.py genindlaeses via >python3 manage.py runserver og naar den reloader
       af sig selv pga script editering'''
    #
    try:
        responseAPIdata = requests.get(network_url, headers=minHeader, timeout=120, verify=False)
        if not responseAPIdata.status_code == 200:
            print("retur status var ikke 200 fra server! ")
            return False
        print("retur kode var: ", responseAPIdata.status_code, "\n"*5)
        print(responseAPIdata.text)
        obj_ClassBuildThreatList = ClassBuildThreatList(responseAPIdata.text)
        getAPIThreatlist = obj_ClassBuildThreatList.funcBuildThreatList()
        return getAPIThreatlist
    except:
        print("\nNo network connection !\n")
        return False



###########################  #########################

saved_list_of_lists = funcGETsavedThreatfeed() # 2-dimensionel list funcGETsavedThreatfeed() returnerer list indkapsling lister
API_list_of_lists = funcAPIThreatfeed()
print("*" * 10, " funcAPIThreatfeed() returnerede: ", API_list_of_lists, "*" * 10)



############# gemmer saved_list_of_lists data i database ##########
"""if saved_list_of_lists != False:
    #
    #funktionen map(str, _en_liste_) den itererer gennem hvert element i listen
    #argumentet str vil stingify hvert element dvs wrappe elementet ind i "" tegn
    #paa den maade undgaas konflikt med special karakterer i start og slut af hvert element !
    #
    # Hver inner_list konverterer jeg til tuple for at kunne parse det til SQL insert kommando
    #
    # list_of_inner_tuples er en list/array bestaaende af elementer hvor hvert element er af data typen tuple
    # og hvert eneste af tuple's elementer er en string

    list_of_inner_tuples = [tuple(map(str, inner_list)) for inner_list in saved_list_of_lists]
    
    print("\n"*5, "list_of_inner_tuples", "\n"*5)
    print(list_of_inner_tuples)
    

    obj_ClassThreatDatabase = ClassThreatDatabase()

    #obj_ClassThreatDatabase.funcCreateTable()
    obj_ClassThreatDatabase.funcDatabaseWrite(list_of_inner_tuples)
    obj_ClassThreatDatabase.funcDatabaseClose()
"""





# ############## gemmer API data i database #########################
if API_list_of_lists != False:
    list_of_inner_tuples = [tuple(map(str, inner_list)) for inner_list in API_list_of_lists]

    obj_ClassThreatDatabase = ClassThreatDatabase()
    # obj_ClassThreatDatabase.funcCreateTable()
    obj_ClassThreatDatabase.funcDatabaseWrite(list_of_inner_tuples)
    obj_ClassThreatDatabase.funcDatabaseClose()


############################ Load more data fra databasen ##############################
def funcLoadfromDB():
    pass

########################### funktioner nedenfor eksekveres via urls.py #########################

def funcThreatfeed(urlPath_arg):
    print(' funktionen "funcThreatfeed" blev eksekveret')
    if API_list_of_lists == False and saved_list_of_lists == False:
        return render(urlPath_arg, template_name='html_files/nofeed.html')
    elif API_list_of_lists != False:
        return render(urlPath_arg, template_name='html_files/threatfeed.html', context={'list_of_lists': API_list_of_lists})
    else:
        # i context skal key value skal indeholde data af typen list
        print(type(saved_list_of_lists))  # <class 'list'>
        return render(urlPath_arg, template_name='html_files/threatfeed.html', context={'list_of_lists': saved_list_of_lists})







#############################################################################

""" Default vil Django loade det html som argument variablen "template_name" peger paa under mappen templates 

og derfor skal der oprettes en mappe med navnet "templates"  under hver sin app mappe. 

Og i templates mappen oprettes html filer """



################################ TEST  ########### ###############################

"""if "id" in dictionary_x.keys():
                print("index nr for key 'id' er: _____ ", list(dictionary_x).index("id")) # index 0
                if dictionary_x["id"]:  # print kun ud hvis value af key 'id' indeholder noget value
                    print(dictionary_x['id'])
                else:
                    inner_list.append('  no id provided   ')
"""


################################ ################################ ###############################
# end
